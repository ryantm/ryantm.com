<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- (c) 2008 Ryan Mulligan All rights reserved. -->
<html lang='en' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type' />
    <meta content="Ryan T Mulligan's personal website." name='description' />
    <meta content='Ryan Mulligan, Ryan, Mulligan, RyanTM' name='keywords' />
    <title>Your Own Fast Image Gallery on Rails - Efficient Methods - Ryan Mulligan</title>
    <!-- / Open Id -->
    <link href='http://www.myopenid.com/server' rel='openid.server' />
    <link href='http://ryantm.myopenid.com' rel='openid.delegate' />
    <meta content='http://www.myopenid.com/xrds?username=ryantm.myopenid.com' http-equiv='X-XRDS-Location' />
    <link href='http://feeds.feedburner.com/RyanTM' rel='alternate' title='Ryan Mulligan' type='application/rss+xml' />
    <link href='../stylesheets/reset-fonts-grids.css' media='screen' rel='stylesheet' type='text/css' />
    <link href='../stylesheets/application.css' media='screen' rel='stylesheet' type='text/css' />
  </head>
  <body>
    <table id='maintable'>
      <tr>
        <td colspan='3' id='banner'>
          <div class='inner'>
            <a class='logo' href='/' title="Ryan Mulligan's homepage">
              RyanTM.com
            </a>
            <h2>Efficient Methods</h2>
            <!-- /=image_tag "logo.png", :alt=>"Ryan Mulligan" -->
          </div>
        </td>
      </tr>
      <tr>
        <td id='main'>
          <div class='inner'>
            <h1>Your Own Fast Image Gallery on Rails</h1>
            published at Tue, 08 Apr 2008 18:10:21 +0000
            <p>
              If you've ever used Facebook's photo application you might have wondered how they make the images go so fast. Since I wanted to have fast viewing of our snapshot galleries over at <a href="http://www.brawlsnapshots.com" title="Brawl Snapshots">Brawl Snapshots</a>, I set out to figure out how to do it.
            </p>
            <p>
              The main component of a fast gallery is caching. By telling the browser to load images in hidden divs before they are actually displayed to the user, the browser cache is primed for the quick switch.
            </p>
            <p>
              The way you request these images in the background is the meat of the problem and the solution depends on what you are trying to do. With Facebook, each gallery has a limited number of photos in it, so Facebook loads all of the imag URLs, comments, and other meta data when you look at the first photo in the gallery. In the case of <a href="http://www.brawlsnapshots.com" title="Brawl Snapshots">Brawl Snapshots</a> this approach wouldn't work because some of our galleries have over 4000 images in them. Loading and rendering the meta-data for 4000 images just to view one would be a little wasteful.
            </p>
            <a href="http://www.ryantm.com/images/fast-gallery-requests.png">
            <img src="http://www.ryantm.com/images/fast-gallery-requests.png" alt="Firebug shows AJAX requests from visiting one image" height="61" width="522" /> Fig 1: Firebug shows AJAX requests from visiting one image</a>
            <p>
              So instead of loading all the data up front I opted to use some AJAX requests to populate my cache as needed. When you go to a image in the Brawl Snapshot Gallery, it first loads the image you are on then it uses AJAX to asynchronously load the next and previous image in the background. After those finish we load the next's next and previous's previous image as well (see figure 1). This gives our viewers a buffer of two really quick images, which gives us ample time to load some more for all but the quickest users.
            </p>
            <p>
              Time to get into the code, most of our fast gallery implementation is available at <a href="http://www.brawlsnapshots.com/javascripts/fast.js" title="Fast Javascript Gallery">http://www.brawlsnapshots.com/javascripts/fast.js</a>. I will try to explain the essential components.
            </p>
            <h3>1. The Populator (populates the cache when needed)</h3>
            <pre>window.onload = function() {&#x000A;  if (YAHOO.env.ua.ie || YAHOO.env.ua.gecko || YAHOO.env.ua.webkit) {&#x000A;    setInterval(populate, 200);&#x000A;  }&#x000A;&#x000A;  function populate() {&#x000A;    var items = $('items');&#x000A;    if (needsNext() &amp;&amp; gettingMoreNext == false) {&#x000A;      id = lastObject(items).id;&#x000A;      gettingMoreNext = true;&#x000A;      new Ajax.Request('/snapshots/'+id+'/next?'+queryString, {asynchronous:true, evalScripts:true, method:'get'});&#x000A;    }&#x000A;&#x000A;    if (needsPrevious() &amp;&amp; gettingMorePrevious == false) {&#x000A;      id = firstObject(items).id&#x000A;      gettingMorePrevious = true;&#x000A;      new Ajax.Request('/snapshots/'+id+'/previous?'+queryString, {asynchronous:true, evalScripts:true, method:'get'});&#x000A;    }&#x000A;}</pre>
            <p>
              I set the populate function to run every 200 milliseconds with the setInterval() function. Inside the populate function we test if we need to get more, or if we are already getting more snapshot pages. If we aren't then we launch an AJAX request to get more. When the AJAX requests return the scripts inside them are automatically evaluated. The code on the server side looks like this:
            </p>
            <pre>def previous&#x000A;  item_parial = render_to_string(:partial=&gt;"snapshots/show", :locals=&gt;{:snapshot=&gt;@snapshot}&#x000A;  render :update do |page|&#x000A;    page.insert_html :top, 'items', item_partial&#x000A;    page &lt;&lt; "newStuff('previous');"&#x000A;  end&#x000A;end&#x000A;</pre>
            <p>
              What this does is push the new snapshot into the top of the #items div, and then notify our page that it worked by called newStuff. Previous pushes onto the top of the #items div, and Next pushes onto the bottom of the #items div. This orientation is important because it lets us navigate through the cache later.
            </p>
            <h3>The Navigator</h3>
            <p>
              If you've followed these rough steps and modified them for your needs, you should have a list of divs inside an #items div that are in gallery order. Now you want to navigate through them using Javascript. To do this we have to make use of the <a href="http://developer.yahoo.com/yui/history/" title="Yahoo! UI Library: Browser History Manager">Yahoo! UI Library: Browser History Manager</a> which will give you cross browser history and make the back button work. Without this library it is very hard to make the back button work on a Javascript navigated gallery. Luckily Yahoo lets you only include the parts of its libraries upon which Browser History Manager Depends:
            </p>
            <pre>&lt;script src="http://yui.yahooapis.com/2.5.1/build/yahoo/yahoo.js"&gt;&#x000A;&lt;script src="http://yui.yahooapis.com/2.5.1/build/event/event.js"&gt;&#x000A;&lt;script src="http://yui.yahooapis.com/2.5.1/build/history/history.js"&gt;&#x000A;&lt;iframe id="yui-history-iframe"&gt;&#x000A;&lt;input id="yui-history-field" type="hidden" /&gt;</pre>
            <p>
              This code only needs to be included once for your gallery viewer, not for each item. Now let's look at the top of the fast.js file where we do some more history initializations
            </p>
            <pre>function stateChange(state) {&#x000A;  if (ignoreOneChange) {&#x000A;    ignoreOneChange = false;&#x000A;    return;&#x000A;  }&#x000A;  var ar = state.split("/");&#x000A;  var our_id = "";&#x000A;&#x000A;  for(piece in ar)&#x000A;    if (ar[piece].indexOf &amp;&amp; ar[piece].indexOf("?") != -1)&#x000A;      our_id = ar[piece].split('?')[0];&#x000A;&#x000A;  toElm = document.getElementById(our_id);&#x000A;  if (toElm)&#x000A;    itemTo(document.getElementById(our_id),false);&#x000A;  else&#x000A;    window.location = state&#x000A;}&#x000A;&#x000A;YAHOO.util.History.register("items", window.location.toString(), stateChange);&#x000A;YAHOO.util.History.initialize("yui-history-field", "yui-history-iframe");&#x000A;&#x000A;var bookmarkedState = YAHOO.util.History.getBookmarkedState('items');&#x000A;if (bookmarkedState != null)&#x000A;  window.location = bookmarkedState;&#x000A;</pre>
            <p>
              stateChange is a function that I register with the history manager to be called every time the browser's location changes. The purpose of stateChange is synchronize the state of the browser with the history, so this is why if the requested spot in history is in the current cache we immediately jump to that image, otherwise we have to tell that page to load with window.location. Then I make sure there is no current bookmarkedState. If someone were to bookmark an AJAX snapshot with ID 30 the URL might look something like: http://bs.com/snapshots/10#/snapshots/30 so you can see why you might want to revert this to http://bs.com/snapshots/30. You need to do this since web servers are not sent any part of the URL after the octothorpe(#) you would end up at snapshot 10 when you wanted to be at snapshot 30.
            </p>
            <p>
              The last thing to cover is how to insert something into the history. Basically whenever we click a Next link we run some javascript. In this case we run nextItem(), which calls updateURL if it is successful.
            </p>
            <pre>function updateUrl() {&#x000A;  var newState = "/snapshots/"+currentItem.id+"?"+queryString;&#x000A;  if ($('yui-history-iframe')&#x000A;    $('yui-history-iframe').contentWindow.document.title = document.title;&#x000A;  YAHOO.util.History.navigate("items", newState);&#x000A;}</pre>
            <p>
              This tells the history manager to navigate to the new state. We also set the title of the iframe here so that the history in Internet Explorer contains the page titles. When the url is updated we need to make sure that the title of the page is updated as well. In order to do this I have an element inside each item div that contains the title it should be, and then I look it up to put as the document title when that snapshot is viewed.
            </p>
            <p>
              Well that about sums up everything I learned about fast galleries. Hopefully this helps you make fast galleries on your own site.
            </p>
          </div>
        </td>
        <td id='sidebar'>
          <div class='inner'>
            <ul class='navigation'>
              <li><a href='../'>Home</a></li>
              <li><a href='../blog'>Blog</a></li>
              <ul>
                <li><a href='../blog/archives'>Archives</a></li>
              </ul>
              <li><a href='../about.html'>About</a></li>
              <ul>
                <li><a href='../resume.html'>Resume</a></li>
                <li><a href='../contact.html'>Contact</a></li>
              </ul>
            </ul>
          </div>
        </td>
      </tr>
      <tr>
        <td colspan='3' id='footer'>
          All writing (except quotations) on www.ryantm.com is <a href='http://creativecommons.org/licenses/publicdomain/'>dedicated to the public domain</a>.
        </td>
      </tr>
    </table>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    var pageTracker = _gat._getTracker("UA-4515791-1");
    pageTracker._initData();
    pageTracker._trackPageview();
    </script>
  </body>
</html>